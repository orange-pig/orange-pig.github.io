<!doctype html><html lang=zh-CN x-data :class=$store.darkMode.class() :data-theme=$store.darkMode.theme()><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>基于Axum的Rust服务器——从0开始工程化项目搭建 | 若烟阁</title><link rel=canonical href=https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/><meta name=author content="鱼人小野"><meta name=description content="随着这几年Rust社区Server领域的生态发展，2024年我觉得是将Rust应用在Web服务器一个比较成熟的时机。本文就是基于这个契机记录下学习Axum服务器框架搭建的经验。
"><meta name=keywords content="Rust,Axum,Tower"><meta name=generator content="Hugo 0.151.0"><meta property="og:url" content="https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"><meta property="og:site_name" content="若烟阁"><meta property="og:title" content="基于Axum的Rust服务器——从0开始工程化项目搭建"><meta property="og:description" content="随着这几年Rust社区Server领域的生态发展，2024年我觉得是将Rust应用在Web服务器一个比较成熟的时机。本文就是基于这个契机记录下学习Axum服务器框架搭建的经验。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-15T14:15:43+08:00"><meta property="article:modified_time" content="2025-10-15T14:15:43+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Axum"><meta property="article:tag" content="Tower"><meta property="og:image" content="https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/cover.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/cover.webp"><meta name=twitter:title content="基于Axum的Rust服务器——从0开始工程化项目搭建"><meta name=twitter:description content="随着这几年Rust社区Server领域的生态发展，2024年我觉得是将Rust应用在Web服务器一个比较成熟的时机。本文就是基于这个契机记录下学习Axum服务器框架搭建的经验。"><link rel=stylesheet href=/blog/css/output.min.css><style>pre{padding:1em;overflow:auto}</style><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js integrity="sha256-4EHxtjnR5rL8JzbY12OKQJr81ESm7JBEb49ORPo29AY=" crossorigin=anonymous></script></head><body x-data="{
    flip: false,
  }"><div id=dream-global-bg></div><nav class="mt-4 lg:mt-8 py-4"><div class="container flex justify-between px-4"><section class="flex items-center gap-4"><div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title=翻转一下！><div class="h-10 rounded-full"><img src=/blog/img/avatar.jpg alt=若烟阁></div></div><div><a href=https://orange-pig.github.io/blog/ class="text-lg font-semibold cursor-pointer">若烟阁</a><div class="text-base-content/60 text-sm">知识浩瀚若烟，或有一瓢。不欲充数泛滥，凝练真知灼见</div></div></section><div class="dropdown dropdown-end sm:hidden"><div tabindex=0 role=button class="btn btn-ghost btn-square" aria-label="Select an option"><ion-icon name=menu class=text-2xl></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md"><li><div role=link tabindex=0 class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title=关于><ion-icon name=information-circle></ion-icon>关于</div></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/blog/posts title=归档><ion-icon name=archive></ion-icon>归档</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/blog/categories title=所有分类><ion-icon name=grid></ion-icon>所有分类</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/blog/tags title=所有标签><ion-icon name=pricetags></ion-icon>所有标签</a></li></ul></div><section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4"><div role=link tabindex=0 class="text-sm font-semibold cursor-pointer hover:underline" @click="flip = !flip" title=关于>关于</div><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/blog/posts title=归档><ion-icon class=group-hover:text-primary-content name=archive></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/blog/categories title=所有分类><ion-icon class=group-hover:text-primary-content name=grid></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/blog/tags title=所有标签><ion-icon class=group-hover:text-primary-content name=pricetags></ion-icon></a></section></div></nav><div class=flip-container :class="{ 'flip-it': flip }"><div class=flipper><div class=front><div class=container><div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4"><div class="hidden lg:block"></div><div class=lg:col-span-2><article class="mx-auto prose prose-quoteless dark:prose-invert" id=dream-single-post-main itemscope itemtype=http://schema.org/Article><meta itemprop=name content="基于Axum的Rust服务器——从0开始工程化项目搭建"><meta itemprop=description content="随着这几年Rust社区Server领域的生态发展，2024年我觉得是将Rust应用在Web服务器一个比较成熟的时机。本文就是基于这个契机记录下学习Axum服务器框架搭建的经验。"><meta itemprop=datePublished content="2025-10-15T14:15:43+08:00"><meta itemprop=dateModified content="2025-10-15T14:15:43+08:00"><meta itemprop=wordCount content="925"><meta itemprop=image content="https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/cover.webp"><meta itemprop=keywords content="Rust,Axum,Tower"><header><h1 itemprop=headline>基于Axum的Rust服务器——从0开始工程化项目搭建</h1><p class=text-sm>星期三, 10月 15, 2025
| <span>5分钟阅读</span>
| <span>更新于
星期三, 10月 15, 2025</span></p><div class="flex justify-between"><div class="flex items-center"><span>@</span>
<span itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>鱼人小野</span></span></div><div class="flex items-center gap-2"><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://x.com/intent/post?text=%e5%9f%ba%e4%ba%8eAxum%e7%9a%84Rust%e6%9c%8d%e5%8a%a1%e5%99%a8%e2%80%94%e2%80%94%e4%bb%8e0%e5%bc%80%e5%a7%8b%e5%b7%a5%e7%a8%8b%e5%8c%96%e9%a1%b9%e7%9b%ae%e6%90%ad%e5%bb%ba&amp;url=https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" target=_blank rel="noopener noreferrer" title="Share on X"><ion-icon class=group-hover:text-primary-content name=logo-x></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://facebook.com/sharer/sharer.php?u=https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" target=_blank rel="noopener noreferrer" title="Share on Facebook"><ion-icon class=group-hover:text-primary-content name=logo-facebook></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://wa.me/?text=%e5%9f%ba%e4%ba%8eAxum%e7%9a%84Rust%e6%9c%8d%e5%8a%a1%e5%99%a8%e2%80%94%e2%80%94%e4%bb%8e0%e5%bc%80%e5%a7%8b%e5%b7%a5%e7%a8%8b%e5%8c%96%e9%a1%b9%e7%9b%ae%e6%90%ad%e5%bb%ba%20https://orange-pig.github.io/blog/posts/coding/%E5%9F%BA%E4%BA%8Eaxum%E7%9A%84rust%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" target=_blank rel="noopener noreferrer" title="Share on WhatsApp"><ion-icon class=group-hover:text-primary-content name=logo-whatsapp></ion-icon></a></div></div></header><section id=dream-single-post-content itemprop=articleBody><p>随着这几年Rust社区Server领域的生态发展，2024年我觉得是将Rust应用在Web服务器一个比较成熟的时机。本文就是基于这个契机记录下学习Axum服务器框架搭建的经验。</p><p>后端语言的选择上，一般不想搞Python、Java或者JS环境的都会选择Go。在服务器领域Rust拥有很多Go的优点：</p><ul><li>单文件无依赖</li><li>二进制文件体积小</li><li>部署简单</li><li>可靠效率高</li></ul><p>还有很多其他语言都不具备的吸引人的特性：</p><ul><li>拥有最好用的包管理和开发工具—— Cargo</li><li>致力于提供极佳开发体验的社区——带来的轻松舒适的学习体验</li><li>大量小巧而强大的 Crates（rust包）——坚实的依靠</li></ul><p>让我们开始吧！</p><blockquote><p>目前文章还未完成规划内容，后续持续补充</p></blockquote><h2 id=准备>准备</h2><p>学习任何一个新东西都要记得，不要给自己增加包袱和限制。</p><p><strong>Keep Simple! 不把事情复杂化，选择最简单的。</strong></p><p>其实，条条大路通罗马。一个最佳的实践就是跟着社区经过时间选择出的资源，选一个符合你学习习惯的跟随学习，过程中多参考其他资料多提问。</p><h3 id=1-安装rust环境>1. 安装Rust环境</h3><p>无需创造更多的教程，跟着官方的引导安装好rust。<a href=https://www.rust-lang.org/zh-CN/learn/get-started target=_blank>入门 - Rust 程序设计语言 (rust-lang.org)</a></p><h3 id=2-配置编辑器vscode>2. 配置编辑器VSCode</h3><p>Rust的开发体验总体上是一种轻巧的感觉，有很多编辑器可以选择，这里以VSCode为例。</p><p>在插件商店搜索并安装下面几个扩展：</p><p><strong>rust-analyzer</strong></p><p>rust插件已经被废弃，而官方招安了 rust-analyzer 插件并把它扶正了。插件本身提供代码补全、定义跳转、引用查找、类型文档提示、语法检查、代码格式化、错误提示和建议等等功能，开箱即用，只需要一个就行，个人感觉比Go的插件好用。</p><p><strong>REST Client （非必须）</strong></p><p>做web开发的小伙伴都可以用到的rest客户端。他通过在文件中编辑rest请求，点击发送并查看结果。虽然，没有Postman的功能强大，但是简单易用覆盖大部分场景。</p><p><strong>Database Client（非必须）</strong></p><p>如果你没有购买安装 Navicat，那么这个插件将会是一个vscode一站式不用换乘的数据库客户端好工具。安装后在侧边栏可直接创建数据库连接，多个连接以文件目录的形式分类。可以对数据库进行新建、查询、插入等一系列基操，覆盖常规的使用场景。</p><h3 id=3-服务端技术选型分析>3. 服务端技术选型分析</h3><p><code>服务端框架</code></p><p>选择 axum，axum 是现在最火热的服务器框架。很多人选它的理由也应该是他小巧而拓展性强，基于 tokio、tower 和 hyper 带来了强大完整的生态，更是因为它专注于人体工程学带来的舒适的开发体验。</p><p><code>数据库连接</code></p><p>选择sqlx，它不是一个ORM库。虽然ORM库已经在其他成熟后端框架中验证有价值，但是好像与rust的语言调性不是很搭，目前的ORM库我觉得都达不到工程化和人体工程学的要求。sqlx 的 api 使用简单，效率高，结合sqlbuilder 我觉得在中小型的项目中我觉得游刃有余。</p><p>拓展：在一个rust 服务器构建模板 rust on nails中使用了 cornucopia 这个库，通过sql反向生成代码，看起来很不错的一个尝试。</p><h2 id=开始搭建>开始搭建</h2><p><strong>注意</strong>：文章内容都可以在模板项目 <a href=https://github.com/orange-pig/rust_project_templates target=_blank>rust_project_templates (github)</a>
内的 <strong>rust-on-bubbles</strong> 中找到完整代码。</p><blockquote><p><strong>Rust on Bubbles</strong> 意为气泡上斑斓多彩的锈迹，表示rust给我们带来的丰富的可能性。</p></blockquote><h3 id=1-创建项目>1. 创建项目</h3><p>执行命令:</p><blockquote><p>cargo new your-project-name</p></blockquote><p>验证一下，默认项目会打印 Hello, world!：</p><blockquote><p>cd your-project-name</p></blockquote><blockquote><p>cargo run</p></blockquote><p><code>拓展一下</code></p><p>情况一：创建一个没有 git 本地的新项目 local-project</p><blockquote><p>cargo new local-project &ndash;vcs none</p></blockquote><p>情况二：初始化一个刚 Clone 下来的空仓库</p><blockquote><p># cd to your project</p><p>cargo init</p></blockquote><h3 id=2-构建目录结构>2. 构建目录结构</h3><p>社区里的示例项目基本都是一个单项目，但是对于工程实际的服务端来说，一个单项目会让事情变得更加复杂。同时，避免搞出更复杂的三层架构，我们将按照服务对象的不同，将代码简单分成两个仓库：</p><ul><li>面向数据库交互的 <strong>db</strong></li><li>面向业务交互的 <strong>server</strong></li></ul><p>这里要用到 cargo 项目管理的 workspace 功能。</p><p>首先，在项目根据目录创建<code>crates</code>目录用来放置多个项目。</p><p>其次，在其中创建二进制项目<code>server</code>和库项目<code>db</code>。</p><blockquote><p>cargo new crates/server</p><p>cargo new crates/db &ndash;lib</p></blockquote><p>🔔 提醒：项目不一定非要放到 crates 目录里，也可以直接放根目录下，只是这么做井然有序一些，你根据自己喜好组织。</p><p>最后，删除根目录下的<code>src</code>目录，并修改根目录下的<code>Cargo.toml</code>为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Cargo.toml data-lang=Cargo.toml><span style=display:flex><span>[<span style=color:#a6e22e>workspace</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>members</span> = [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;crates/*&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>resolver</span> = <span style=color:#e6db74>&#34;2&#34;</span>
</span></span></code></pre></div><p>运行<code>cargo run</code>验证一下，输出 Hello, world!</p><p>👀 拓展：需要了解 Cargo.toml 更多的配置，可查看官方文档 <a href=https://rustwiki.org/zh-CN/cargo/reference/manifest.html target=_blank>清单格式 - Cargo 手册 中文版 (rustwiki.org)</a></p><h3 id=3-初始化-server-项目>3. 初始化 server 项目</h3><p>依次执行下面添加依赖包：</p><blockquote><p>cd crates/server</p><p>cargo add axum</p><p>cargo add axum-macros</p><p>cargo add serde -F derive</p><p>cargo add tokio -F full</p><p>cargo build</p></blockquote><p>💡 提示：添加了依赖库后运行一下build是一个好习惯，可以让后面编写代码时代码提示处于已准备好的状态，避免因为依赖找不到导致代码报错，制造出大量的panic。</p><p>这些包只是目前会用到的，在开发中需要用什么包再添加什么包，feature(可选功能) 也是需要用到了再去 Cargo.toml 中手动添加，做到 <em><strong>如无必要勿增实体</strong></em> 即可。安装后<code>Cargo.toml</code>是这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/Cargo.toml data-lang=server/Cargo.toml><span style=display:flex><span>[<span style=color:#a6e22e>package</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;server&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2021&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>axum</span> = <span style=color:#e6db74>&#34;0.7.7&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>axum-macros</span> = <span style=color:#e6db74>&#34;0.4.2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>serde</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;1.0.210&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;derive&#34;</span>] }
</span></span><span style=display:flex><span><span style=color:#a6e22e>tokio</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;1.40.0&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;full&#34;</span>] }
</span></span></code></pre></div><p>将<code>main.rs</code>内容替换为下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-main.rs data-lang=main.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> axum::{response::Html, routing::get, Router};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::net::TcpListener;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## build application
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
</span></span><span style=display:flex><span>        .route(<span style=color:#e6db74>&#34;/&#34;</span>, get(Html(<span style=color:#e6db74>&#34;&lt;h1&gt;Hello World!&lt;/h1&gt;&#34;</span>)))
</span></span><span style=display:flex><span>        .route(<span style=color:#e6db74>&#34;/hello&#34;</span>, get(<span style=color:#f92672>||</span> <span style=color:#66d9ef>async</span> { <span style=color:#e6db74>&#34;Hello Rust on Bubble!&#34;</span> }));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## run app with hyper, listening globally on port 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> listener <span style=color:#f92672>=</span> TcpListener::bind(<span style=color:#e6db74>&#34;0.0.0.0:3000&#34;</span>).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    axum::serve(listener, app).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行<code>cargo run</code>启动服务器，在浏览器输入<code>localhost:3000</code>和<code>localhost:3000/hello</code>查看结果。</p><h3 id=4-实现用户api>4. 实现用户api</h3><p>首先，需要先定义业务对象，让我们创建<code>models</code>模块。</p><blockquote><p>🏂 Cargo 定义每一个文件都是一个模块，每一个文件夹也是一个模块。文件模块中的导出是通过<code>pub</code>关键字，文件夹需要mod.rs文件来指定需要向外部<code>pub</code>哪些文件模块，从而形成命名空间的层级结构。</p></blockquote><p>在<code>server/src</code>目录下创建<code>models</code>目录，在其中创建<code>mod.rs</code>和<code>user.rs</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-models/user.rs data-lang=models/user.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> serde::{Deserialize, Serialize};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Deserialize, Serialize, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> email: String,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-models/mod.rs data-lang=models/mod.rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>mod</span> user;
</span></span></code></pre></div><p>然后，定义路由处理器，让我们创建<code>handlers</code>模块。</p><p>在<code>server/src</code>目录下创建<code>handlers</code>目录，在其中创建<code>mod.rs</code>和<code>user.rs</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-handlers/user.rs data-lang=handlers/user.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> axum::{
</span></span><span style=display:flex><span>    http::StatusCode,
</span></span><span style=display:flex><span>    Json,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span>  <span style=color:#66d9ef>crate</span>::models::user::User;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[axum_macros::debug_handler]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_user</span>() -&gt; Result<span style=color:#f92672>&lt;</span>Json<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span>, StatusCode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Ok(Json(User {
</span></span><span style=display:flex><span>        name: <span style=color:#e6db74>&#34;alpha&#34;</span>.to_string(),
</span></span><span style=display:flex><span>        email: <span style=color:#e6db74>&#34;a@a.com&#34;</span>.to_string(),
</span></span><span style=display:flex><span>    }))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-handlers/mod.rs data-lang=handlers/mod.rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>mod</span> user;
</span></span></code></pre></div><p>最后在<code>main.rs</code>中配置路由，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/src/main.rs data-lang=server/src/main.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> axum::{routing::get, Router};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> handlers::user::get_user;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::net::TcpListener;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> handlers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> models;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user_router <span style=color:#f92672>=</span> Router::new().route(<span style=color:#e6db74>&#34;/&#34;</span>, get(get_user));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## build application
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new().nest(<span style=color:#e6db74>&#34;/user&#34;</span>, user_router);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## run app with hyper, listening globally on port 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> listener <span style=color:#f92672>=</span> TcpListener::bind(<span style=color:#e6db74>&#34;0.0.0.0:3000&#34;</span>).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    axum::serve(listener, app).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行<code>cargo run</code>启动服务器，在浏览器输入<code>localhost:3000/user</code>查看结果。</p><blockquote><p>💨 后续可继续按照这个模式添加更多的路由和handler。</p></blockquote><h3 id=5-初始化-db-项目>5. 初始化 db 项目</h3><p>初始化db项目前需要准备好你的数据库，sqlx 支持 mysql、postgresql、sqllite，以 postgresql(简称pgsql) 为例。</p><p>在 db 项目中创建 src 的同级目录 <strong>migrations</strong>，用来放置初始化数据库的 sql 文件，在其中创建一个 db.sql 文件。</p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f2f649ebd91f49ec961985134a05339b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bG85Lq65bCP6YeO:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTQ5MTM3NTk5Nzg1NjYyMSJ9&amp;rk3s=f64ab15b&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1761113756&amp;x-orig-sign=9wFAPA9Do1LqZ%2BsBzMqH7Yhjd7I%3D" alt></p><p>假设你已经在开发环境上安装好了 pgsql 和 vscode 的 <strong>Database Client 插件</strong>，那么只需要在 vscode 的侧边栏上选择 <strong>Database</strong> 面板中创建你的 pgsql 的连接。</p><p>然后，在创建的数据库连接上点击 “+” 号创建数据库，如下图：</p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/8b88da63345140f099cc7cdb635f0c22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bG85Lq65bCP6YeO:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTQ5MTM3NTk5Nzg1NjYyMSJ9&amp;rk3s=f64ab15b&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1761113756&amp;x-orig-sign=KHZD6V6zZkcMbvJkU52XO0x8Jt8%3D" alt></p><p>就会在左侧创建一个临时的初始化 sql 文件，我们不使用这个临时文件，只是复制其第一行的连接信息到前面创建的 db.sql 文件中第一行。（在不使用 <strong>Database Client 插件</strong> 的情况下，这行连接信息不是必须的）</p><p>然后，在下面添加如下的 sql 代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-migrations/db.sql data-lang=migrations/db.sql><span style=display:flex><span><span style=color:#75715e>-- Active: 6666666666666@@127.0.0.1@5432
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>DATABASE</span> your_db_name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#a6e22e>users</span> (
</span></span><span style=display:flex><span>  id serial <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name <span style=color:#66d9ef>VARCHAR</span>(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  email <span style=color:#66d9ef>VARCHAR</span>(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;users&#34;</span> (<span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;email&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;user1&#39;</span>, <span style=color:#e6db74>&#39;user1@mail.com,&#39;</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;user2&#39;</span>, <span style=color:#e6db74>&#39;user2@mail.com,&#39;</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;user3&#39;</span>, <span style=color:#e6db74>&#39;user3@mail.com,&#39;</span>);
</span></span></code></pre></div><p>如果你已经安装了 <strong>Database Client</strong> 插件，那么就可以直接点击 sql 行上的 Run 一次执行完所有的 sql，完成数据库创建。同时，你可以使用其他任何熟悉的方式执行 sql。</p><p>接着我们开始 db 库的初始化，依次执行下面添加依赖包：</p><blockquote><p>cd crates/db</p><p>cargo add sqlx -F runtime-tokio,tls-native-tls,derive,macros,postgres</p><p>cargo add serde -F derive</p><p>cargo build</p></blockquote><p>安装后<code>Cargo.toml</code>是这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-db/Cargo.toml data-lang=db/Cargo.toml><span style=display:flex><span>[<span style=color:#a6e22e>package</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;db&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2021&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>serde</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;1.0.210&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;derive&#34;</span>] }
</span></span><span style=display:flex><span><span style=color:#a6e22e>sqlx</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.8.2&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;runtime-tokio&#34;</span>, <span style=color:#e6db74>&#34;tls-native-tls&#34;</span>, <span style=color:#e6db74>&#34;derive&#34;</span>, <span style=color:#e6db74>&#34;macros&#34;</span>, <span style=color:#e6db74>&#34;postgres&#34;</span>] }
</span></span></code></pre></div><blockquote><p>⚠️ <strong>严重注意</strong>：由于 <strong>ring</strong> 这个库会导致任何更改都会触发项目的重新编译，而 sqlx 的 features 选择 result-tls 等依赖于 <strong>ring</strong> 库的功能时，就会导致 wactch 整个项目并不会进行增量编译迅速重启，而是要等待全部重新编译。由于非常的耗时，它会让你想要修改代码后马上运行起服务进行调试成为不可能。</p></blockquote><p>将 lib.rs 中的代码替换为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-db/src/lib.rs data-lang=db/src/lib.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> sqlx::{postgres::PgPoolOptions, Error, PgPool};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DbState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> pool: <span style=color:#a6e22e>PgPool</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connc_db</span>() -&gt; Result<span style=color:#f92672>&lt;</span>PgPool, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    PgPoolOptions::new()
</span></span><span style=display:flex><span>    .max_connections(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    .acquire_timeout(Duration::from_secs(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>    .connect(<span style=color:#e6db74>&#34;postgres://your_db_username:your_db_password@localhost/your_db_name&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>💡 记得修改代码中的<strong>连接字符串</strong>为你自己的！！！</p></blockquote><p>然后，执行下面命令添加<code>db</code>的依赖到<code>server</code>：</p><blockquote><p>cd crates/server</p><p>cargo add db</p><p>cargo build</p></blockquote><p>下面这一行会被加入到<code>server/Cargo.toml</code>中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/Cargo.toml data-lang=server/Cargo.toml><span style=display:flex><span><span style=color:#a6e22e>db</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>, <span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#34;../db&#34;</span> }
</span></span></code></pre></div><p>最后，在 server/src/main.rs 中加入如下代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/src/main.rs data-lang=server/src/main.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> db::connc_db;
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## init DB pool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> _pool <span style=color:#f92672>=</span> connc_db().<span style=color:#66d9ef>await</span>.expect(<span style=color:#e6db74>&#34;Can&#39;t connect to database&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>运行<code>cargo run</code>启动服务器，服务成功启动代表数据库连接成功。</p><p>🔔 提醒：启动服务失败会打印下面的报错信息，这个时候你需要需要检查你的数据库连接和数据库连接字符串</p><blockquote><p>Can&rsquo;t connect to database</p></blockquote><h3 id=6-配置环境变量>6. 配置环境变量</h3><p>前面直接硬编码数据库连接字符串到了代码中，在实际工程实践中这样做是很不合理的。我们应该通过环境变量来配置数据库的连接字符串。</p><p>执行下面命令添加环境变量依赖库：</p><blockquote><p>cd crates/db</p><p>cargo add dotenvy</p><p>cargo add dotenvy_macro</p><p>cargo build</p></blockquote><p>首先，在根目录下创建<code>.env</code>文件，将你的连接字符串设置为环境变量<code>DATABASE_URL</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-.env data-lang=.env><span style=display:flex><span>DATABASE_URL<span style=color:#f92672>=</span>postgres://your_db_username:your_db_password@localhost/your_db_name
</span></span></code></pre></div><p>然后，修改 lib.rs 的代码为下面这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-db/src/lib.rs data-lang=db/src/lib.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> dotenvy::dotenv;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> sqlx::{postgres::PgPoolOptions, Error, PgPool};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{env, time::Duration};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DbState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> pool: <span style=color:#a6e22e>PgPool</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connc_db</span>() -&gt; Result<span style=color:#f92672>&lt;</span>PgPool, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    dotenv().expect(<span style=color:#e6db74>&#34;.env not found!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> db_connection_str: String <span style=color:#f92672>=</span> env::var(<span style=color:#e6db74>&#34;DATABASE_URL&#34;</span>).expect(<span style=color:#e6db74>&#34;DATABASE_URL must be set&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    PgPoolOptions::new()
</span></span><span style=display:flex><span>        .max_connections(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>        .acquire_timeout(Duration::from_secs(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>        .connect(<span style=color:#f92672>&amp;</span>db_connection_str)
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行<code>cargo run</code>启动服务器，服务成功启动代表数据库连接成功。</p><h3 id=7-实现数据库查询>7. 实现数据库查询</h3><p>在 db/src 中新建文件<code>user.rs</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-db/src/user.rs data-lang=db/src/user.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> serde::{Deserialize, Serialize};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> sqlx::PgPool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(sqlx::FromRow, Deserialize, Serialize, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> id: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> email: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>query_user</span>(pool: <span style=color:#a6e22e>PgPool</span>) -&gt; Option<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    sqlx::query_as::<span style=color:#f92672>&lt;</span>_, User<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;SELECT * FROM users&#34;</span>)
</span></span><span style=display:flex><span>        .fetch_optional(<span style=color:#f92672>&amp;</span>pool)
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>        .expect(<span style=color:#e6db74>&#34;Query error!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 lib.rs 中公开</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-db/src/lib.rs data-lang=db/src/lib.rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>mod</span> user;
</span></span></code></pre></div><p>在 server 中创建 <strong>app-state.rs</strong> 定义应用的状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/src/app_state.rs data-lang=server/src/app_state.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> db::DbState;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> db: <span style=color:#a6e22e>DbState</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 server 的 main.rs 中将数据库状态加入app状态中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/src/main.rs data-lang=server/src/main.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> app_state::AppState;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> axum::{routing::get, Router};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> db::{connc_db, DbState};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> handlers::user::get_user;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::net::TcpListener;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> app_state;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> handlers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> models;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## init DB pool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> pool <span style=color:#f92672>=</span> connc_db().<span style=color:#66d9ef>await</span>.expect(<span style=color:#e6db74>&#34;Can&#39;t connect to database&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## init app state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> state: <span style=color:#a6e22e>AppState</span> <span style=color:#f92672>=</span> AppState {
</span></span><span style=display:flex><span>        db: <span style=color:#a6e22e>DbState</span> { pool: <span style=color:#a6e22e>pool</span> },
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user_router <span style=color:#f92672>=</span> Router::new().route(<span style=color:#e6db74>&#34;/&#34;</span>, get(get_user));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## build application
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new().nest(<span style=color:#e6db74>&#34;/user&#34;</span>, user_router).with_state(state);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ## run app with hyper, listening globally on port 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> listener <span style=color:#f92672>=</span> TcpListener::bind(<span style=color:#e6db74>&#34;0.0.0.0:3000&#34;</span>).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    axum::serve(listener, app).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 server 的 handlers/user.rs 的添加对 db 函数 query_user 的调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-server/src/handlers/user.rs data-lang=server/src/handlers/user.rs><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::{app_state::AppState, models::user::User};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> axum::{extract::State, http::StatusCode, Json};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> db::user::{query_user, UserEntity};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[axum_macros::debug_handler]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_user</span>(State(state): <span style=color:#a6e22e>State</span><span style=color:#f92672>&lt;</span>AppState<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Json<span style=color:#f92672>&lt;</span>User<span style=color:#f92672>&gt;</span>, StatusCode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> acc: Option<span style=color:#f92672>&lt;</span>UserEntity<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> query_user(state.db.pool).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(acc) <span style=color:#f92672>=</span> acc {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(Json(User {
</span></span><span style=display:flex><span>            name: <span style=color:#a6e22e>acc</span>.name,
</span></span><span style=display:flex><span>            email: <span style=color:#a6e22e>acc</span>.email,
</span></span><span style=display:flex><span>        }));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Err(StatusCode::<span style=color:#66d9ef>INTERNAL_SERVER_ERROR</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行<code>cargo run</code>启动服务器，在浏览器输入<code>localhost:3000/user</code>就可以查看查询结果。</p><h3 id=8-错误处理规划中>8. 错误处理（规划中&mldr;）</h3><h3 id=9-日志记录规划中>9. 日志记录（规划中&mldr;）</h3><h3 id=10-web页面>10. Web页面</h3><p>在现在的前端生态下，服务器的模板页面就拿来搞搞首页、博客、文档就好了。用来做web应用还是要差很多，所以这一块可以直接使用纯前端项目与后端分离部署，也可以自己试试搞服务端渲染。不在这里做模板化html的介绍了。</p><h3 id=11-开发配置规划中>11. 开发配置（规划中&mldr;）</h3></section></article></div><div x-data=tocHighlighter() @scroll.window=debouncedScroll class="hidden lg:flex lg:flex-col lg:items-end"></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 若烟阁</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div><div class=back><div class=container><div class="dream-grid dream-grid-about"><div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column"><article class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"><div class=card-body><div class=card-title>Me</div><div class="prose dark:prose-invert"><p>It&rsquo;s me, It&rsquo;s all.</p></div></div></article></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 若烟阁</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div></div></div><script>window.lightTheme="emerald",window.darkTheme="forest"</script><script src=https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin=anonymous></script><script src=/blog/js/grid.min.js></script><script src=/blog/js/main.min.js></script><script src=/blog/js/toc.min.js></script><script type=module src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin=anonymous></script><script nomodule src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin=anonymous></script></body></html>